# 리눅스 소개

# 오픈소스 프로젝트

- **GNU ( GNU's Not Unix )**
    
    GNU 시스템을 개발하기 위해 1984년에 시작
    
- **GPL (General Public License)**
    
    소프트웨어의 실행, 연구, 공유, 수정의 자유를 최종 사용자에게 보장하며 GPL은 가장 널리 알려진 강한 카피레프트 사용 허가이며, 이 허가를 가진 프로그램을 사용하여 새로운 프로그램을 만들게 되면 파생된 프로그램 역시 같은 카피레프트를 가져야 한다
    
    자신이 만들 소프트웨어에 GPL 라이선스를 가지는 코드가 한 줄 이라도 들어가면 소유권을 포기하라는 뜻이다.
    완전한 평등과 완전한 공유 정신을 뜻한다. 
    오픈소스의 대명사격인 리눅스가 GPL을 대표한다고 할수 있다.
    
    **소프트웨어에 관련된 다섯 가지 의무**
    
    ```
    GNU 일반 공중 사용 허가서는 누구에게나 다음의 다섯 가지의 의무를 저작권의 한 부분으로서 강제한다.
    
    1. 컴퓨터 프로그램을 어떠한 목적으로든지 사용할 수 있다. 다만 법으로 제한하는 행위는 할 수 없다.
    2. 컴퓨터 프로그램의 실행 복사본은 언제나 프로그램의 소스 코드와 함께 판매하거나 소스코드를 무료로 배포해야 한다.
    3. 컴퓨터 프로그램의 소스 코드를 용도에 따라 변경할 수 있다.
    4. 변경된 컴퓨터 프로그램 역시 프로그램의 소스 코드를 반드시 공개 배포해야 한다.
    5. 변경된 컴퓨터 프로그램 역시 반드시 똑같은 라이선스를 취해야 한다. 즉 GPL 라이선스를 적용해야 한다.
    ```
    
- **Open Source**
    
    오픈소스 소프트웨어는 사용자가 소프트웨어를 실행하고 복제하고 배포하고 학습하고 개작하고 향상시킬수 있는 소프트웨어이다.
    

## GNU란 무엇인가?

GNU는 운영 체제의 하나이자 컴퓨터 소프트웨어의 모음집이다. GNU는 온전히 자유 소프트웨어로 이루어져 있으며그 중 대부분이 GNU 프로젝트의 GPL로 라이선스된다.

GNU는 "GNU's Not Unix!"(GNU는 유닉스가 아니다!)의 재귀 약자이며 이렇게 선정된 이유는 GNU의 디자인이 유닉스 계열이지만 자유 소프트웨어인 점과 유닉스 코드를 포함하지 않는다는 점에서 차별을 두려는 것이다.

GNU 프로젝트는운영 체제 커널, GNU HURD를 포함하고 있으며 이는 자유 소프트웨어 재단(FSF)에서 본래 초점을 두고 있었던 것이다. 그러나 GNU가 아닌 커널(가장 유명한 것으로 리눅스)은 GNU 소프트웨어와 함께 사용할 수도 있다. 즉, 허드(Hurd) 커널은 아직 운영용으로 준비되지는 않았는데, 이는 어떻게 GNU 시스템이 일반적으로 사용되고 있는지를 설명한다.GNU 소프트웨어와 리눅스 커널의 결합은 리눅스(또는 GNU/리눅스)로 알려져 있다.

## GNU 프로젝트의 설립자 리처드 스톨먼

프로젝트의 창립자 리처드 스톨먼은 GNU를 "사회에 대한 기술적 수단'으로 보았다. 이와 관련해 Lawrence Lessig는 스톨먼의 책 《자유 소프트웨어, 자유 사회》 제2판에서 스톨먼은 소프트웨어의 사회적 관념과 어떻게 자유 소프트웨어가 공동체와 사회 정의를 조성할 수 있는지에 대해 썼다고 언급하였다.

GNU란 GNU는 UNIX가 아니라는 뜻이다. GNU 프로젝트에서 만들어진 중요한 것 중 하나가 GNU 공용 라이선스(GPL)다. 이 라이선스는 해당 소프트웨어가 완벽하게 공개이며 그 누구도 이러한 자유를 없앨 수 없음을 분명하게 명시한다. 소프트웨어는 사용할 수 있고 이득을 얻기 위해 되팔 수 있지만 이러한 재판매가 이워질 경우 판매자는 반드시 변경된 부분을 포함한 모든 소스 코드를 공개해야 한다. 왜냐하면 재판매된 패키지도 역시 GPL 정책을 따르게 되어 있기에 자유롭게 배포될 수 있고 제3자가 이익을 얻기 위해 다시 판매할 수 있다. -위키백과

GNU는 유닉스 형태의 운영체제로 자유 소프트웨어이며 여러분의 자유를 존중합니다. GNU의 개발은 여러분의 자유를 억압할 수 있는 소프트웨어를 사용하지 않도록 하였습니다.- gnu.org

```
프로그래머는 자신이 제작한 소프트웨어로 인해 발생한 어떠한 손해에도 법적 책임이 없다.
법적 책임은 사용한 당사자에게 있다.
```

## 오픈 소스 소프트웨어의 장점

1. **프로그램을 원하는 어떠한 목적으로도 실행할 수 있는 자유.**
2. 프로그램이 어떻게 동작하는지 학습하고, 자신의 필요에 맞게 개작할 수 있는 자유. 이것을 위해서는 소스 코드에 대한 접근이 전제되어야 합니다.
3. 이웃을 도울 수 있도록 복제물을 재배포할 수 있는 자유.
4. **프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있게 그것을 발표할 자유. 이를 위해서는 역시 소스 코드에 대한 접근이 전제되어야 합니다.**
5. **코드상의 오류들이 많은 사람들의 눈에 의해 보다 쉽게 감지되고 빠르게 수정된다.**
6. GPL시스템하에서는 프로그래머들이 소송에 대한 두려움 없이 마음껏 코드를 배포할 수 있다.

## 리눅스란?

- **리눅스는 유닉스 계열의 운영체제**
    
    POSIX 호환
    
- **리눅스는 합성어**
    
    리누스 토발즈와 UNIX의 합성어
    
- **리눅스 커널코드**
    
    자유 소프트웨어 재단 라이선스 정책인 GNU GPL을 따른다.
    

---

## 리눅스란 무엇인가?

**리눅스(Linux)는 컴퓨터 운영 체제(서버 운영체제)**이며, 그 커널을 뜻하기도 한다. 리눅스는 자유 소프트웨어와 오픈 소스 개발의 가장 유명한 표본으로 들 수 있다. 리눅스는 다중 사용자, 다중 작업(멀티태스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)이다.

엄밀하게 따지면 이‘리눅스’라는 용어는 리눅스 커널만을 뜻하지만, 리눅스 커널과 GNU 프로젝트의 라이브러리와 도구들이 포함된, 전체 운영 체제(GNU/리눅스라고도 알려진)를 나타내는 말로 흔히 쓰인다. 리눅스 배포판은 핵심 시스템 외에 대다수 소프트웨어를 포함한다. 현재 200여 종류가 넘는 배포판이 존재한다.

초기에 리눅스는 개개인의 애호자들이 광범위하게 개발하였다. 이후 리눅스는 IBM, HP와 같은 거대 IT 기업의 후원을 받으며, **서버 분야에서 Unix와 Microsoft Windows 운영 체제의 대안으로 자리 잡았다**.

리눅스는 데스크톱 컴퓨터를 위한 운영 체제로서도 인기가 늘어가고 있다. 지지자와 분석자들은 이와 같은 성공을 벤더 독립성과 적은 개발비, 보안성과 안전성에서 기인한다고 분석한다.

리눅스는 처음에 인텔 386 마이크로프로세서를 위해 개발되었으나 현재는 다양한 컴퓨터 아키텍처를 지원한다. 리눅스는 개인용 컴퓨터에서부터 슈퍼 컴퓨터는 물론 휴대 전화, 개인용 비디오 레코더와 같은 임베디드 시스템까지 광범위하게 이용되고 있다.

리누스 토발즈가 커널을 개발하고 GNU에서 개발된 나머지 명령어 프로그램들을 도입하여 현재의 리눅스로 발전해왔다.

현재는 각 국가들의 국가 운영체제로 리눅스를 채택하고 있다.

한국의 경우에는 일본, 중국, 미국의 영향을 받아 아직은 50:50정도로 가져가고 있으며 원천기술 개발이 부족한 시점이다.

# 리눅스의 특징

---

- 리눅스는 누구가 자유롭게 사용할 수 있는 운영체제
- 리눅스는 다중 유저, 다중 작업을 지원하는 시스템
- 리눅스는 강력하고 안정적인 네트워크를 지원하는 운영체제
- 리눅스는 가격대 성능비가 강력한 운영체제
- 리눅스는 이식성이 강력한 운영체제

---

## 리눅스의 장점

- **누구나 자유롭게 사용할 수 있는 운영체제이다.**
    
    오픈 소스로 인해 소스를 가공 & 변형 & 재배포 할 수 있는 GPL라이센스가 적용된다. 리눅스는 오픈소스나 배포에 치명적인 오류가 발생하더라도 여러 사람이 공동으로 소스를 수정 할 수 있도록 오픈되어 있기 때문에 MS와 같은 비오픈소스에 비해 정확하고 빠른 패치의 사용이 가능하다.
    
- **여러 사용자(Multi-user)가 동시에 사용할 수 있는 환경을 제공한다.**
    
    많은 사용자가 동시에 리눅스 시스템에 접속하더라도 다른 운영체제에 비해 안정적이고 탁월한 성능을 유지한다.
    
- **다중 작업(Multi Tasking) 및 가상 터미널(Virtual Terminal)환경을 지원한다.**
    
    윈도우는 한 화면에서 여러개의 창을 열어 다중작업을 하는 반면, 리눅스는 가상터미널 환경에서 작업 할 수 있는 멀티캐스팅을 지원한다. 리눅스는 윈도우에서 도스창과 창은 콘솔화면 창을 6개까지 띄워 작업하는 것을 말하는데, 이는 도스와 같은 환경의 컴퓨터를 6대 사용하는 것과 같다.
    
- **GUI방식의 X Window 를 지원한다.**
    
    리눅스에서는 2가지 형태의 작업 환경을 제공해준다. 첫 번째는 콘솔형태와 같은 TUI(Text User Interface)방식이고, 두 번째는 윈도우와 같은 GUI(Graphic User Interface)방식이다.
    
- **CPU 구애가 없는 운영체계이다.**
    
    리눅스는 x86을 기반으로 하는 인텔계열의 모든 CPU를 완벽히 지원하며, 인텔 486 CPU 이상의 기종에서도 무리 없이 작동 할 수 있도록 설계되어 다른 운영체제에 비해 적은 시스템 자원을 가진 시스템에서도 리눅스를 사용 할 수 있다.
    
- **강력하면서 안정적인 네트워크를 지원하는 운영체계이다.**
    
    하나의 어플리케이션에 오류가 발생하여도 전체 시스템이 중지되지 않다. 각 어플리케이션은 메모리에서 고유한 개별 위치를 차지하며 사용자 프로세스는 운영 체제 프로세스와 완전히 분리되어 있어, 어플리케이션에서 오류가 발생하더라도 운영 체제는 전혀 영향을 받지 않다.
    
- **리눅스에서의 하드웨어 드라이버 설정 및 하드웨어 사용이 매우 쉽다.**
    
    리눅스는 드라이버를 커널에서 모듈의 형태로 지원하고 있어, 제조업체의 드라이버 없이도 동일한 칩셋을 사용한 하드웨어에 대해서는 범용적으로 지원한다.
    
- **이식성이 강한 운영체계이다.**
    
    리눅스는 Unix의 프로그램과 소스를 쉽게 이식하고 컴파일 할 수 있다.
    

# 리눅스의 역사

---

![https://en.wikipedia.org/wiki/Linux](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcde73ad-a6c6-48ed-84bf-b76aa936094b/Untitled.png)

https://en.wikipedia.org/wiki/Linux

---

## 리눅스의 탄생 및 발전

핀란드 헬싱키 대학의 학생이었던 리누스 토발즈에 의해 만들어진 리눅스는 **Unix(UNIX)에서부터 시작되었다**.

실질적인 모태는 1987년에 Andrew S. Tanenbaum 교수가 개발한 **Minix**이다. Minix는 말 그대로 작은 Unix란 뜻으로 이것을 접한 리누스 토발즈가 지속적인 개발을 통해 1994년 3월에 **커널**버전 1.0을 탄생시켰다.

FSF의 설립자인 리차드 스톨만이 GNU 프로젝트를 추진한 후 1990년 무렵쯤 되었을 때 GNU 시스템은 거의 완성단계이 이르렀을 때 핵심 부분인 커널이 완전하지 않은 상태였다. 때마침 리누스가 만들어낸 리눅스가 GNU에 큰 힘을 실어주었고 **GNU 시스템의 운영체제로 리눅스를 채택**하게 된 것이다. GNU(GNU is not unix)란 쉽게 말해 자유 소프트웨어의 생산과 보급을 장려하기 위해 세워진 재단이라고 할 수 있다.

우리가 리눅스를 'GNU/Linux'라고 부르는 것은 바로 이와같은 배경때문이다.

현재 많이 알려진 리눅스의 배포판으로는 슬랙웨어, 레드햇, 와우리눅스, 데비안, 리눅스-맨드레이크, 오픈 리눅스 등이 있다.

리눅스는 1991년도에 출시되었다. 늦게 출시 되었지만 현재 계속 발전중인 OS의 하나이다.

## **리눅스(Linux)의 배포판**

슬랙웨어, 레드햇, 맨드리바, 수세, 칼데라, 한컴리눅스 등 (엑스 윈도우, 인터넷 서버 및 클라이언트 프로그램과 그 외의 여러 가지 유틸리티들을 안정적으로 작동 될 수 있는 리눅스 배포판을 개발)

리눅스 배포판은 워드프로세서, 스프래드시트, 미디어 플레이어, 데이터베이스 등 여러 가지 소프트웨어 애플리케이션의 모음이다. 운영체제는 리눅스 커널과 GNU 프로젝트에서 가져온 라이브러리와 유틸리티, X 윈도 시스템의 그래픽으로 구성된다.

용량을 맞춰서 X 윈도를 빼거나 용량이 작은 GNU 유틸리티를 선택하기도 한다. 전 세계에 300개 이상의 배포판이 있다고 한다. 커널과 패키지 대부분이 무료 소프트웨어고 오픈 소스를 따르므로 각 배포판의 형태는 매우 다양하다.

페도라(Fedora)는 레드햇(Red Hat), openSUSE는 노벨(Novell), 우분투(Ubuntu)는 캐노니컬 등의 기업이 관리하는 배포판이다. 데비안(Debian)이나 젠투(Gentoo)는 리눅스 커뮤니티 기반의 배포판이다.

이에 해당하지 않는 배포판이 있는데 대표적인 것이 슬랙웨어(slackware)다. 리눅스 배포판이 처음부터 있던 것은 아니다. 리눅스 배포판은 전문가가 아닌 개인 이용자를 위해 만들어졌다.

[참고]

기본 리눅스 커널에 자사의 프로그램을 같이 포함하여 특정 사용자를 위한 (서버, 클라이언트, 모바일, 임베디드)OS를 구성하여 만들어 내는 OS를 배포판이라 한다.

리눅스 명령어 형식

Linux CMD Format
리눅스에서는 명령어 입력으로 작업을 수행하는 TEXT 모드(CLI)를 주로 사용한다. 명령어 사용법을 익혀야 하며, 명령어를 입력하면 쉘에서 명령어를 해석하여 작업을 수행한다. 명령어에는 옵션(Options)과 인자(Arguments)가 있는데, 옵션은 명령어의 동작을 다르게 하는데 사용하고, 인자는 명령어의 인자나 옵션의 인자로 사용될 수 있다.
[명령어 형식]
# Command [options] [Arguments]
​
각 문자의 구분은 white space(공백문자)로 구분한다.
[root@serverX ~]#  ls    -l   /var
        |          |      |    |
       쉘프롬프트  명령어 옵션  인자
​
명령어를 사용하는 다양한 형식은 다음과 같다.
- "# Command" 사용하는 경우
[EX] # ls
- "# Command Options" 사용하는 경우
[EX] # ls -l
- "# Command Arguments" 사용하는 경우
[EX] # ls /var
- "# Command options Arguments" 사용하는 경우
[EX] # ls –l /var
- 한 개의 명령어 라인에 여러 명령어 사용 하는 경우
[EX] # cd /test ; ls –l
​
(예) "명령어" 형식을 사용하는 경우
# ls 
# cal 
# uname
​
(예) "명령어 + 옵션" 형식을 사용하는 경우
# uname -sr  
# uname -a 
# ls -l
​
(예) "명령어 + 인자" 형식을 사용하는 경우
# cd /etc/sysconfig/network-scripts 
# ls /var 
# cal 2002
​
(예) "명령어 + 옵션 + 인자" 형식을 사용하는 경우
# ls -l /var
# find / -name core
​
[참고] 옵션에 대한 설명
명령어의 옵션은 자리를 바꾸거나 혹은 합쳐서 사용해도 같은 의미로 동작한다.
# ls -a -l -F
# ls -al -F
# ls -alF
# ls -Fla

< 명령어의 옵션을 약자로 사용하지 않을 경우 >
명령어의 옵션을 약자 형태로 쓰지 않기 위해서는 "--(double dash)"을 붙인다.
# ls --all    (# ls -a)
​
[참고 & 주의] 옵션의 인자가 존재하는 경우의 예
예) # find / -name core -type f
EX : # find . -name file1 -type f

# cmd -i -f arg1(0)
# cmd -f arg1 -i(0)
# cmd -if arg1(0)
# cmd -fi arg1(X) 

특정 값이 인자에 포함되어야 하는 경우는 인자 뒤에 값이 들어가야 한다.
옵션의 순서는 변경이 가능하지만 옵션과 같이 지정되는 인자의 경우는 옵션뒤에 와야하는 것을 주의한다.
​
도움말
man 명령어
 # man ls
 # man –k calendar
 # whatis passwd
 # man –s 5 passwd
 # man ls | col –b > ls.txt
 # info ls
 # which ls
 # whatis ls
man 명령어
[명령어 형식]
# man ls /* 명령어나 파일의 이름으로 검색하는 경우 */
# man -k calendar  /* keyword로 검색하는 경우 (색인파일 생성 필요)*/
# whatis passwd 
# man -s 1 passwd/* section번호로 검색하는 경우 */
​
[EX1] 명령어에 대한 man 페이지 확인
(간략하게 정보 확인) # ls --help   (# CMD --help)
(자세하게 정보 확인) # man ls      (# man CMD)
​
# man ls
빠져나오는경우 q
​
[참고] man 페이지 내에서 페이지 제어
<Enter> 하나의 라인씩 밀리면서 출력한다.
<Space> <--> <CTRL + B> 한 페이지씩 밀리면서 출력한다.
      CTRL + B로 이전 페이지로 돌아간다.
/-a     <--> n, N    (n: next) 특정 단어를 검색하여 찾는다. 두 개 이상 존재할경우는 n으로 다음 단
    어를 찾는다 
: 자주 사용되는 기능
/OPTIONS 
/EXAMPLES 
/Examplesls
q 
h
​
[EX2] 명령어를 알지 못하는 경우
# man –k calendar
calendar: nothing appropriate  -> 에러메시지가 나오면
​
처음 –k 옵션을 실행하게 된다면 색인에 대해 생성이 되어있지 않기 때문에 에러 메시지를 출력한다
[참고] CENTOS7은 에러메시지가 나오지 않는다.(100%는 아니다.)
# makewhatis 
-> 약간 시간이 걸린다.(약 1분 정도) [ 명령어에 대한 색인을 생성한다 ] << centos 5,6 버전에 해당
​
[참고]  7버전 이상에서 색인 데이터베이스 생성
처음 서버를 설치한 경우에 스케쥴러 시간이 되지 않으면 아직 색인이 생성되어 있지 않다. 
그렇기 때문에 수동으로 색인을 생성하는 작업을 해준다.
# cd /etc/cron.daily/
# ls
grotate  man-db.cron  mlocate
# ./man-db.cron
# 
​
[참고]  8버전 이상에서 색인 데이터베이스 생성
man-db.cron 파일이 없기 때문에 레포지토리에서 설치 이후 진행한다.
# dnf -y install man-db-cron
# cd /etc/cron.daily
# ls
grotate  man-db.cron
# ./man-db.cron
>> 색인 생성중
#
​
[참고] 9버전 이상에서 색인 데이터베이스 생성
# mandb
​
# man -k calendar
cal (1)              - display a calendar
cal (1p)             - print a calendar
difftime (3p)        - compute the difference ...
​
[EX3] 섹션 별로 검색 할 경우
# whatis passwd
passwd (5)           - 패스워드 파일
sslpasswd (1ssl)     - compute password hashes
passwd (1)           - update user's authentic...
​
# man -s 1 passwd /* passwd 명령어 매뉴얼 페이지 */
# man -s 5 passwd /* /etc/passwd 파일 매뉴얼 페이지 */
​
섹션번호로 보는 방법이 필요한 이유는 # passwd CMD형식으로 검색하게 된다면 1번 섹션에 대해서만 출력된다. 2~ 이후의 섹션에 대하여 검색하기 위해서는 –s 옵션을 사용하는 섹션으로 검색하는 방법에 대하여 알고있어야한다.
# man passwd
# man -s 1 passwd
# man -s 5 passwd
​
매뉴얼 페이지 각 섹션별 정보
매뉴얼 페이지 각 섹션별 정보
  1     누구나 실행할 수 있는 사용자 명령 (User Commands)
  2     시스템 호출 (System Calls), 즉 커널에서 제공하는 함수
  3     C 라이브러리 함수 (C Library functions)
  4     디바이스와 네트워크 인터페이스 (Devices and Network Interfaces), 즉 /dev 디렉토리에 있는 특별한 파일들
  5     파일 포맷 (File Formats), 예를 들어 /etc/passwd
  6     게임과 데모 (Games and Demos)
  7     환경, 테이블, 매크로 (Environments, Tables, and Macros) 등의 잡다한 여러 가지들
  8     시스템 관리자만 실행할 수 있는 시스템 관리용 명령들 (Maintenance Commands)
  9     커널 루틴에 관련된 문서들의 리눅스만의 독자적인 저장소
  n     새로운 문서들의 저장소. 보다 적당한 장소로 이동된다.
  o     오래된 문서들의 저장소. 유예 기간으로 보관되고 있는 것들이다.
  l     특정 시스템에 대한 로컬 문서들
​
[EX4] 추가적인 정보 확인 명령어
# info ls 
man 페이지에서 간략하게 나오고 info에서 확인하라는 메시지가 하단에 나타나는 경우에 info 명령어를 확인한다.
# pinfo ls 
map 형식으로 나타내주며 색깔표시가 보기좋게 되어있다.
info로 확인해야 할 일이 있다면 pinfo를 사용하기 바란다.

# apropos ls     (# man -k calendar) 
# man -k ls

# whatis ls    명령어의 메뉴얼 파일 섹션 확인
ls (1)               - list directory contents
ls (1p)              - list directory contents    
# whereis ls   명령어의 바이너리 파일 경로, 메뉴얼 파일 실제 경로
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
# which ls     명령어 실제 경로
alias ls='ls --color=auto'
        /usr/bin/ls 
# ls —-help
​
# whatis ls 명령어의 모든 섹션 확인
ls (1)               - 경로의 내용을 나...
ls (1p)              - list directory contents
# whereis ls 메뉴얼 페이지의 경로 확인
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
# which ls 명령어의 실제 경로 확인
alias ls='ls --color=auto'
	/usr/bin/ls
# ls --help 명령어의 간단한 사용 형식 확인
​
passwd 명령어
암호 변경 권한 차이
root 사용자 : 모든 사용자의 암호를 변경 가능
일반 사용자 : 자신의 암호만 변경 가능
암호 변경 시 이전 암호 입력 여부
root 사용자 : 암호 변경시 이전 암호 물어보지 않고 변경 가능
일반 사용자 : 이전 암호를 반드시 맞추어야만 새로운 암호 입력 가능
[명령어 형식]
# passwd 
# passwd fedora
​
[EX1] 관리자가 자신의 암호 변경하는 경우
[TERM1] root 사용자 터미널
# passwd
Changing password for user root. <변경하는 계정의 ID가 출력된다>
New UNIX password: (fedora) 
BAD PASSWORD: it is based on a dictionary word
Retype new UNIX password: (fedora)
passwd: all authentication tokens updated successfully. <연속으로 동일한 비밀번호를 입력시 변경>
​
# passwd root
Changing password for user root.
New UNIX password: (soldesk) 
BAD PASSWORD: it is based on a dictionary word
Retype new UNIX password: (soldesk) 
passwd: all authentication tokens updated successfully.
​
# passwd fedora
Changing password for user fedora.
New UNIX password: (123user) 
BAD PASSWORD: it is based on a dictionary word
Retype new UNIX password: (123user) 
passwd: all authentication tokens updated successfully.
​
[TERM2] fedora 사용자 터미널
# ssh fedora@localhost
The authenticity of host 'localhost (127.0.0.1)' can't be established.
RSA key fingerprint is 3b:25:5b:9a:ae:0f:ba:fc:85:66:73:d4:fc:e2:78:c6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
fedora@localhost's password: (123user)
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora)
$ passwd
Changing password for user fedora.
Changing password for fedora
(current) UNIX password: (123user)    /* 이전 비밀번호 확인 */
New UNIX password: (P@ssw0rd##1.)         /* 새로운 비빌번호 입력 */
Retype new UNIX password: (P#ssw0rd##1.)  /* 새로운 비빌번호 동일하게 재 입력 */
passwd: all authentication tokens updated successfully.
$ exit 
#
​
비밀번호를 변경하는 일 외에도 passwd 삭제, 사용자 계정에 대한 잠금, 해제 등 여러 기능이 있다.
(복원) 관리자가 사용자의 암호 변경
fedora 사용자의 암호를 fedora로 변경
# passwd fedora 
-> 일반사용자는 아이디와 암호를 동일하게 설정할수 없다.
​
stdin옵션
# echo 'password' | passwd --stdin [USERNAME]
​
시스템의 기본적인 정보를 확인하는 명령어
uname 명령어
 # uname –a
 # cat /etc/redhat-release
date 명령어
 # date
 # date +%m%d
uname 명령어
운영체제에 맞는 애플리케이션(Application)을 설치하려면 운영체제의 종류와 버전에 대한 정보등 확인 할 수 있어야 한다. 또한 운영체제의 시간을 확인하고 서버와 동기화를 시키는 작업등을 할 수 있어야 한다.
uname 명령어를 사용하는 경우
운영체제의 종류와 버전 확인(OS + Version)
커널 버전 확인(Kernel Version)
[명령어 형식]
# uname [OPTIONS]
​
[명령어 옵션]
옵션 : 설  명
-a : 모든 정보
-s : 운영체제 종류 (예: Linux) 
-r : 운영체제 릴리즈 (예: 2.6.18-164.11.1.el5) 
-n : 호스트 이름 (예: linux200) 
-i : 머신아키텍쳐 (예: i386) 
-p : 프로세스 종류 (예: athlon)
​
[EX1] uname 명령어
# uname -a
Linux server1.example.com 4.18.0-147.el8.x86_64 #1 SMP Wed Dec 4 21:51:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
​
uname 명령어의 출력 결과 해석
Linux                              (-s) 커널 이름(kernel name)
server1.example.com                (-n) 호스트 이름(Hostname)
4.18.0-147.el8.x86_64             (-r) 커널 릴리즈
커널 버전 : 주버전.부버전.fix버전-몇개의업데이트가있었는가
#1 SMP Wed Aug 7 18:08:02 UTC 2019 (-v) 커널 버전
x86_64                             (-m) 머신 하드웨어 이름
x86_64                             (-p) CPU 종류
x86_64                             (-i) 하드웨어 구현 플랫폼
GNU/Linux                          (-o) 운영체제 종류
​
# uname -s  /* 커널 이름 */
# uname -n  /* 호스트 이름 */
# uname -r  /* 커널 릴리즈 */
# uname -sr /* 커널 이름과 릴리즈 */
# uname -v  /* 커널 버전 */
# uname -m  /* 머신 하드웨어 이름 */
# uname -p  /* CPU 종류 */
# uname -i  /* 하드웨어 구현 플랫폼 */
# uname –o  /* 운영체제 종류 */
# uname -nsr
​
[EX2] 설치된 리눅스 운영체제 종류 확인
# uname -a
Linux server1.example.com  4.18.0-147.el8.x86_64 #1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
​
uname 대신에 시스템 정보를 확인하는 명령어
# hostnamectl
Static hostname: server1.example.com
       Icon name: computer-vm
         Chassis: vm 🖴
      Machine ID: e6c3061aab7d4db1904499fdfb0c8b0d
         Boot ID: 35a2166869f547679dcd448834ae9096
  Virtualization: vmware
Operating System: Rocky Linux 9.0 (Blue Onyx)      
     CPE OS Name: cpe:/o:rocky:rocky:9::baseos
          Kernel: Linux 5.14.0-70.17.1.el9_0.x86_64
    Architecture: x86-64
 Hardware Vendor: VMware, Inc.
  Hardware Model: VMware Virtual Platform
​
릴리즈 정보 확인하기
# ls /etc/*release
/etc/os-release  /etc/redhat-release  /etc/rocky-release  /etc/system-release

/etc/centos-release
/etc/os-release
/etc/redhat-release > /etc/centos-release의 링크파일
/etc/system-release
# cat /etc/redhat-release
Rocky Linux release 9.0 (Blue Onyx)
​
[EX3] 문서(Documentation) 사이트(운영체제 버전별 정보 확인)
https://docs.redhat.com/
http://www.centos.org/docs/
http://www.centos.org/docs/3/CentOS 3.X
http://www.centos.org/docs/4/CentOS 4.X
http://www.centos.org/docs/5/CentOS 5.X
centos6부터는 RHEL 레드햇 공식 웹사이트를 이용해야한다.
[참고]
centos는 RHEL을 전신으로 개발된 무료용버전이기 때문에 기술들이 레드햇에서 문서가 있는 경우가 많다.
두가지 도메인 주소를 모두 기억해두자.
​
리눅스 기본환경 
CLI / GUI 환경전환과 로그인 로그아웃
언어변경
제어문자
운영체제 종료와 재부팅
관리자 암호 변경
CLI / GUI 환경전환과 target name 
system runlevel - 시스템의 현재 상태를 나타내는 숫자.
init telinit
system runlevel type
0 - halt                          시스템종료
1 - single user mode              싱글유저모드(시스템복구, 관리자 비밀번호 변경)
2 - multiuser                     멀티유저가능(단 nfs 사용불가)
3 - full multiuser                멀티유저가능(모든 기능 사용 가능)
4 - unused                        이후를 위해 예약된 번호
5 - full multiuser, graphical     그래픽모드를 지원하는 멀티유저 
6 - reboot                        재부팅
​
runlevel 5는 runlevel3의 모든 기능과 GUI기능의 결합이다.
시스템 런레벨의 확인
# who -r
            run-level 5  2020-03-11 09:40
            운영레벨=5    운영레벨 전환 시간
# runlevel
N 5
# init 3
login: root
password: redhat
# runrevel
5 3
# init 5
# who -r
run-level 5  2020-03-11 10:23                   last=3
현재 구성 정보   시스템 전환시간                  이전 구성 정보 레벨 확인

# systemctl get-default
graphical.target     => init 5과 동일
​
system run level은 무엇인가?
런레벨은 하나의 시스템에서 여러 가지의 운영 환경을 제공하는 것을 의미한다.
리눅스 서버의 경우 운영 환경의 전환을 통해 GUI CLI 의 변경이 가능하다.
EX: GUI > TUI,CLI
언어변경
현재 사용중인 언어 확인
 # echo $LANG
 # locale
현재 지원되는 언어 종류 확인
 # locale -a
임시적인 언어 변경
 # export LANG=C ;  echo $LANG
영구적인 언어 변경
 # localectl set-locale LANG='변경할 언어'
현재 사용중인 언어 확인하기
# set | grep ^LANG   
LANG=ko_KR.UTF-8
​
# locale

LANG=ko_KR.UTF-8
LC_CTYPE="ko_KR.UTF-8"
LC_NUMERIC="ko_KR.UTF-8"
LC_TIME="ko_KR.UTF-8"
LC_COLLATE="ko_KR.UTF-8"
LC_MONETARY="ko_KR.UTF-8"
LC_MESSAGES="ko_KR.UTF-8"
LC_PAPER="ko_KR.UTF-8"
LC_NAME="ko_KR.UTF-8"
LC_ADDRESS="ko_KR.UTF-8"
LC_TELEPHONE="ko_KR.UTF-8"
LC_MEASUREMENT="ko_KR.UTF-8"
LC_IDENTIFICATION="ko_KR.UTF-8"
LC_ALL=

​
임시적으로 언어를 변경하기
# export LANG=ko_KR.euckr 

# export LANG=C
​
임시적으로 언어를 변경해야 하는 경우 :
현재 지정된(설정된) 언어셋을 실행해야 하는 프로그램에서 지원하지 않을 경우에 사용한다.
TOOL을 실행시에 $LANG의 변수를 읽어들인다. 만약 지원하지 않는 언어로 지정되어있을 경우에는 글자가 정상적으로 출력되지 않을 가능성이 있다.
제어문자
Ctrl + C    Terminates the command currently running.
Ctrl + D    Indicates end-of-file or exit.
① <CTRL + C>  =  ^C
현재 실행중인 프로세스를 인터럽트(Interrupt) 걸어서 종료한다.
인터럽트 - 인터럽트는 컴퓨터에 장착된 장치나 컴퓨터 내의 프로그램으로부터 오는 신호로서 운영체계가 하던 일을 멈추고 다음에 무엇을 할 것인지를 결정하게 한다. 인터럽트 신호가 입력되게 된다면 이전의 상태에 상관없이 인터럽트된 신호를 먼저 처리한다.
# sleep 500
	# ls 
	# locale
  반응이 없다.
<CTRL + C>
#    < 명령어 실행이 가능해 진다.
​
sleep 명령어를 수행중에 <CTRL + C>를 이용하여 실행을 종료한다.
② <CTRL + D>
"파일의 끝(EOF)" 의미 또는 "현재 쉘 종료(exit)" 의미를 갖는다.
(파일의 끝(EOF) 의미의 <CTRL + D>)
# mkdir –p /test	/* 최상위 디렉토리 아래 test 디렉토리 생성 */
# cd /test	      /* 생성한 test 디렉토리로 이동 */
# pwd             /* 현재 작업 디텍토리 확인*/
 /test
# cat > file1	    /* 파일에 내용 입력 */
Hello, Linux <Enter>
<CTRL + D>        /*“파일의 끝”의미 */
​
# cat file1  /* 입력된 파일 내용 확인 */
Hello, Linux
​
(쉘 종료(exit) 의미의 <CTRL + D>)
# ps /* 프로세스 확인*/
# bash /* 쉘 실행 */
# ps/* 프로세스 확인 */

PID  TTY          TIME CMD
3290 pts/0    00:00:00 bash
3608 pts/0    00:00:00 bash
​
[참고] BASH : 명령어 해석기
ls 라는 명령어 하나만의 결과를 보기 위해서도 하드디스크, 키보드, 모니터등 여러 가지 장치를 제어해야 하는데 bash를 통한 명령어가 명령어 해석이 된 다음 커널에서 각종 장치를 제어하여 결과를 출력해준다.
현재 ps로 나오는 결과의 bash는 사용중인 명령어 해석기가 bash라는 것을 나타내준다.
bash                       bash
----------+--wait------>+----------> 부모쉘은 자식 쉘이 실행되는동안 wait상태로 대기하다가
          |             |            반환즉시 wait상태를 종료하고 명령어 입력을 받는다
          | bash        |
          +------------>+ 자식 쉘이 실행된다

# <CTRL + D>/* 쉘 종료 (logout이 되는 것을 확인) */ 

bash
----------+            +--------->
          |            |
          | bash       |
          +------------+
​
# ps
PID TTY          TIME CMD
3290 pts/0    00:00:00 bash /* 이전에 실행한 bash shell이 종료 */

# <CTRL + D> /* 쉘 종료 (logout이 되는 것을 확인) */
GUI – 터미널이 종료된다
CLI – login 창으로 돌아간다

# init 3
login: root
password: redhat
# ps
# bash
# ps 
^d입력
# ps
^d
login:  

​
운영체제 종료와 재부팅
시스템 종료
# halt
# poweroff
# init 0
# shutdown -h now
시스템 재부팅
 # reboot
 # init 6
 # shutdown -r now
다양한 시스템 종료 명령어
시스템을 종료하는 경우(halt)
이 명령어들은 시스템을 바로 종료한다.
# shutdown -h now      /* -h : halt */ /* 만약 시간을 지정하지 않는다면 기본 60초 이후 종료된다 */
# halt 
# poweroff
# init 0
​
시스템을 재부팅(reboot)
# shutdown -r now      /* -r : reboot */
# reboot
# init 6
​
예약 종료
# shutdown -h +5        /* -h : halt, +5 : 5분의 유예기간 */

Shutdown scheduled for 수 2018-02-28 20:01:27 KST, use 'shutdown -c' to cancel.

Broadcast message from root@server1 (Wed 2018-02-28 19:56:27 KST):

The system is going down for power-off at Wed 2018-02-28 20:01:27 KST!
 /* 현재 상태에서 5분간 대기후 종료 */

# shutdown -c      /* 종료 취소 */

Broadcast message from root@server1 (Wed 2018-02-28 19:57:20 KST):

The system shutdown has been cancelled at Wed 2018-02-28 19:58:20 KST!
/* 시스템 종료를 취소 */
이전버전에서는 제어문자 <CTRL + C>를사용하여 취소를 했지만 centos7에서는 shutdown -c 명령어를 사용하여 취소해야한다.
​
예약 종료 취소
# shutdown -c       /* -c: cancel, 관리자 및 다른 관리자가 예약종료를 취소시 사용 */

Broadcast message from root@server1 (Wed 2018-02-28 20:00:10 KST):

The system shutdown has been cancelled at Wed 2018-02-28 20:01:10 KST!
​
시스템을 종료하거나 재부팅 하는 경우
1. 정기 PM
2. 하드웨어 업그레이드
3. 대규모 업데이트
4. * 해킹의 경우 *
​
관리자 암호 변경
관리자 암호 변경 방법
 # passwd
관리자 암호(password) 변경
초기 설치 시에는 비밀번호를 쉽게 주고 설치를 완료할 수 있다. 하지만 실제로 외부에서 접속을 하거나 사용을 하기 전에는 조직의 정책에 맞게 비밀번호를 변경해야하기 때문에 비밀번호를 변경하는 방법을 알고 있어야한다.
root 사용자는 모든 사용자의 암호 변경이 가능하고, 일반 사용자는 자신의 암호 변경만 가능하다.
passwd 명령어 다음에 지정된 사용자가 없으면 자신의 암호를 변경하는 경우이다.
# passwd    /* 변경된 root 계정의 비밀번호를 복구한다. */
Changing password for user root.
New UNIX password: (centos)                       /* 새 패스워드 입력 */
BAD PASSWORD: it is based on a dictionary word
Retype new UNIX password: (centos)                /* 새 패스워드 확인 메시지 */
passwd: all authentication tokens updated successfully.

root 사용자의 비밀 번호 변경 중
새  암호:
잘못된 암호: 암호는 8 개의 문자 보다 짧습니다
새  암호 재입력:
passwd: 모든 인증 토큰이 성공적으로 업데이트 되었습니다.
​
date
date를 이용해서 시간을 확인한다. 만약 시간이 잘못 설정되어 있으면 date나 rdate,ntp명령어를 통해 시간을 재설정 해준다. 이때 rdate,ntp명령어를 사용하는 경우 서버로부터 시간을 동기화하여 사용 할 수 있으므로 시스템의 시간을 정확하게 설정 할 수 있다.
일반 사용자(EX: fedora)는 date 명령어를 통해 시간 확인만 가능하고, 관리자(EX: root)는 date 명령어를 통해 시간 확인이나 변경이 가능하다.
root 사용자 : 현재 시간을 설정 및 확인 할 수 있다.
일반 사용자 : 현재 시간만 확인 할 수 있다. (즉, 관리자가 아니면 시간을 변경 할 수 없다.)
[명령어 형식]
# date /* 시스템 시간 출력 */
# date 07241300/* 시스템 시간 변경 */
# date +%m%d /* 시간 출력 형태 변경 */
​
[EX1] 운영체제 시간 확인 및 변경
# date /* 현재 운영체제에 설정되어 있는 시간 출력 */
요일 월 일 시:분:초 UTC 년
Tue Jan 26 05:16:44 KST 2010
​
시간정보 변경후 확인하기
테스트를 위하여 터미널을 하나 더 실행
[TERM1]# watch -n 1 date

아래 작업들은 [TERM2]에서 작업한다.
# date 08161300     /* 8월 16일 13:00 로 설정 년도는 생략가능하다 */
       월.일.시.분 단위로 작성
# date 081613002009 /* 2009년 8월 16일 13:00 */
       월.일.시.분.연도
​
[참고] 8버전에서는 rdate 명령어가 존재하지 않는다.
[EX2] 운영체제 시간을 원격 서버에 동기화 하기
[EX3] date 명령어의 시간 출력 형식 변경하여 출력하기
대부분의 프로그램은 하루에 한번 씩 로그 파일을 만들도록 하는 경우가 많이 존재한다. 
이런 경우 date 명령어를 아래와 같이 응용하여 사용하는 경우가 많다.
실무에서 많이 사용되는 로그 파일 이름 형식 : file_0807.log
[시간 포맷 형식]
# date +%m%d        /* %m : month, %d : day */
# date +%m%d_%H%M   /* %H : hour, %M : Minute */
​
[실습] 시간정보 포맷 변경하여 파일 저장
# cd /test
# rm -rf /test/*
# touch file_`date +%m%d`.log
# ls -l
# ls -l
total 0
-rw-r--r--. 1 root root 0 Mar 11 15:18 file_0311.log

date 명령어에서 시간형식 포맷 변경시 자주 사용되는 옵션
%m 월
%d 일
%H 시
%M 분
%S 정수 초
%s 1970.01.01 기준으로 흐른 초시간
[참고]
역 따옴표를 표현하기 위한 또 다른 방법
# touch file_$(date +%m%d).log
​
[참고] 시간의 종류(Clock Type)
시간(Clock)
- Software Clock : 운영체제의 시간
- Hardware Clock : 하드웨어(펌웨어) 시간
​
■ Software clock 
# date

■ Hardware Clock 
# hwclock --show

HW-OS 시간 동기화

# hwclock --systohc    /* System Time -> Hardware Clock */
# hwclock --hctosys    /* Hardware Clock -> System Time */
​
관리자 비밀번호 변경
관리자 비밀번호를 변경하는 경우
주기적인 비밀번호 변경
비밀번호를 잊어버린경우
해킹들의 외부 침입으로 인한 경우
[EX] 기본적인 비밀번호 변경
# passwd

일상적으로 변경하는 경우에는 passwd 명령어로 변경한다.

PWD 명령어
파일 작업 중이나 자료의 위치로 이동 할 경우 현재 내가 작업하고 있는 디렉토리의 위치를 알고 이동할 디렉토리를 지정해야 한다. 디렉토리 이동 관련 명령어에는 pwd 명령어, cd 명령어가 있다.
현재 내가 작업하고 있는 디렉토리의 위치를 절대경로를 통해 / (root)부터의 전체 경로를 출력해 준다.
[명령어 형식]
# pwd
​
[EX1] pwd 명령어 실습
# cd 
# pwd
/root

# cd /etc/sysconfig/network-scripts 
# pwd           /* 위치가 변경되었다. */
/etc/sysconfig/network-scripts/
# echo $PWD

# cd 
# pwd
/root
​
CD 명령어
작업 디렉토리를 변경하고자 할 때 사용한다. 인자(Argument)인 디렉토리명은 이동하고자 하는 경로명을 나타낸다. 디렉토리 명을 지정하지 않고 cd 명령어를 단독으로 사용하면 현재 작업디렉토리가 어디에 있든지 사용자의 홈 디렉토리로 이동한다. cd 명령어는 디렉토리를 변경하는 명령어이다. cd 명령어를 사용하여 디렉토리 경로를 변경하는 경우 상대경로(Relative Path)나 절대경로(Absolute Path)를 사용 할 수 있다.
상대경로(Relatvie Path)는 이동하는 기준이 현재 디렉토리이며, 현재 디렉토리를 기준으로 위, 아래로 이동하는 할 때 사용한다. 
절대 경로(Absolute Path)는 이동하는 기준이 최상위 디렉토리(/)이며, root(/) 디렉토리를 기준으로 이동할 때 사용한다.
경로(PATH)
- 상대경로(Relative PATH) # cd dir1
- 절대경로(Absolute PATH) # cd /dir1
작업시에는 상대경로를 사용하여 이동하는 경우, 즉 작업 디렉토리안에 들어가서 직접 파일을 다루는 방법을 권장한다. 이것은 명령어 실수로 인해 불의의 사고를 예방할 수 있거나, 최소화 할 수 있기 때문이다.

상대경로(Relative PATH)
[EX1] 상대경로 사용하는 경우
# cd /etc
# pwd
/etc
# cd sysconfig 
# cd network-scripts 
# ls -a /* .디렉토리 , ..디렉토리 */
.  ..  ifcfg-ens33

# cd .     /* 현재 디렉토리 (cd /etc/sysconfig/network-scripts/와 같은 뜻) */
# pwd
/etc/sysconfig/network-scripts/
# cd .. /* 상위 디렉토리 (내 기준에서 상위 디렉토리로 이동) */
# pwd
/etc/sysconfig/
​
[참고] 디렉토리 표시
.  디렉토리는 현재 디렉토리
.. 디렉토리는 상위 디렉토리
​
# pwd
/etc/sysconfig/
# cd ../../ /* 상위 디렉토리, 상위 디렉토리 */
# pwd
/
​
[EX2] 상위 디렉토리에 파일 만들기
# cd /etc/sysconfig/network-scripts 
# touch ../../test.txt 
# cd ../../ 
# pwd
/etc/
# ls –l test.txt
​
절대경로

A는 최상위 디렉토리인 / 디렉토리를 뜻 한다.
B,C는 디렉토리의 구분자
처음 위치한 /는 최상위 디렉토리를 나타내지만 뒤에 나와 있는 /는 구분자의 역할이다. 
따라서 /etc/sysconfig/network-scripts 와 /etc/sysconfig/network-scripts/는 같은 뜻을 가지게 된다.
# cd /tmp , cd /tmp/
# cd /etc/sysconfig 
# cd /usr
​
로그인 된 사용자의 홈 디렉토리 이동
root 사용자로 로그인 하였기 때문에 root의 홈디렉토리로 이동한다.
만약 fedora 사용자로 로그인 하였다면 fedora의 홈디렉토리로 이동하게 된다.
사용자의 홈디렉토리
root 사용자 -> /root
일반 사용자 -> /home/$USER
root 사용자인 경우
# id
uid=0(root) gid=0(root) groups=0(root)
-> root 사용자인 경우
​
fedora 사용자인 경우
# ssh fedora@localhost 
fedora 사용자로 로그인

$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora)
$ cd 
$ pwd
/home/fedora
$ exit 
# cd ~fedora
​
[차이점]
# cd ~fedora
# cd ~/fedora

~fedora의 경우는 fedora의 홈 디렉토리 /home/fedora로 이동하는 경우의 명령어이며
~/fedora의 경우는 fedora의 홈 디렉토리로 이동하지 않고 현재 계정의 홈 디렉터리 하위의 fedora 디렉터리로 이동하는 /$HOME/fedora의 의미를 가진다.

[참고] 

$ cd
$ cd ~
$ cd $HOME

동일 하게 자신의 홈 디렉토리로 이동한다.
​
사용한 이전 디렉토리로 이동
[시나리오] 사용자가 /etc 디렉토리에서 작업을 하다가 /home/user01 디렉토리로 이동하는 경우 상대경로나 절대경로를 사용하는 경우는 불편하게 된다. 이런 경우 이전 디렉토리로 바로 이동하기 위해서 "cd - " 명령어를 사용한다.
/etc <------> /etc/sysconfig/network-scripts
# cd /etc 
# ls


# cd /etc/sysconfig/network-scripts 
# ls 


# cd /etc 
# ls 


# cd - 
# pwd <cd – 로 이동이후 현재 디렉토리를 확인한다.>
/etc/sysconfig/network-scripts
-> 반복적으로 사용해본다.
​
옆에 있는 디렉토리로 이동하는 경우
								 /
								 |
-------+---------+-------+--------+------
       |         |       |
.... test ..... export   etc
        |
 --+----+-----+---    • 현재 디렉토리 : dir2
 dir1       dir2      • 목적 디렉토리 : dir1
​
[EX] 디렉토리 이동 실습
# cd /test 
# rm –rf /test/* 

# mkdir dir1 dir2 
# cd dir2 
# pwd
/test/dir2

# cd .. 
# pwd
/test

# cd dir1 
# pwd
/test/dir1

# cd ../dir2 
# pwd
/test/dir2

# cd ../dir1 
# pwd
/test/dir1
​
최상위 디렉터리에서부터 다시 이동하는 것보다는 근처에 있는 디렉터리라면 상대 경로를 통해 이동하는 것이 더 빠르게 이동할 수 있는 경우도 있다.

(실무 예) 프로그램 설치
						/usr/local/apache2
									|
                  +---- bin   (# cd ../bin)
									|
                  +---- conf  (# cd ../conf)
									|
									+---- docs  (# cd ../docs)
									|
                  +---- ....
​
디렉토리 관리 명령어
ls 명령어
 # ls -l dir1
 # ls -ld dir1
mkdir 명령어
rmdir 명령어
ls 명령어
디렉토리에 있는 내용을 확인하고자 할 때 (ls 명령에 대해서 확인 : # man ls)
[명령어 형식]
# ls -l 
# ls –l dir1 

# ls -ld 
# ls –ld dir1 

# ls -altr
​
옵션 : 설명
-a : 모든 파일 표시, 여기에는 숨김 파일(점(.)으로 시작하는 파일)도 표시한다.
-l : 디렉토리가 지정되는 경우 디렉토리의 내용을 자세히 보여준다. 또한 파일의 내용 이 지정되는 경우 파일의 속성 정보를 자세히 보여준다. 파일 종류, 링크 수, 소유자명, 그룹명, 파일 크기, 최종 수정일 및 용량, 파일명 표시한다.
-R : 해당 디렉토리와 서브디렉토리의 모든 내용을 표시
-F : 디렉토리인 경우에는 디렉토리 "/"표시를 하고 실행 파일인 경우는 뒤에 "*"표시를 한다.
-i : 해당 파일의 inode 번호를 표시한다.
-n : 파일의 소유자와 그룹을 숫자로( UID : GID )표시한다.
-d : 찾고자 하는 디렉토리에 관한 정보만을 표시한다.
[EX1] ] ls 명령어의 기본 사용법 테스트
	(실습용 구조)
	
	/test ---+-- file1
	         |
	         +-- dir1 --- file2
​
실습 준비
# cd /test
# rm -rf /test/* 
# touch file1 
# mkdir dir1 
# touch dir1/file2 

[root@server1 test]# tree
.
├── dir1
│   └── file2
└── file1


# ls –lR(# find . )

.:
total 0
drwxr-xr-x. 2 root root 18 Mar 25 13:23 dir1
-rw-r--r--. 1 root root  0 Mar 25 13:23 file1

./dir1:
total 0
-rw-r--r--. 1 root root 0 Mar 25 13:23 file2
​
(ls -l 출력 결과 해석)
-----------------------------------------------------------------------
-            파일의 종류(File Type), -(일반파일), d(디렉토리파일)
rw-r--r--.   퍼미션 모드(Permission Mode) <마지막의.은 ACL 관련 코드>
1            링크 수(Hard Link Count)
root         소유자(Owner)
root         그룹(Group)
0            파일의 크기(File Size), 기본 단위 : bytes
Mar 25 13:23 수정 또는 생성 시간(Mtime: Modify Time) [자세한 정보를 보려면 stat명령어를 사용]
file1        파일의 이름(File Name)
-----------------------------------------------------------------------
​
# ls -ld . /* 현 디렉토리 정보를 자세히 출력( .디렉토리 출력) */
drwxr-xr-x. 3 root root 29 Mar 25 13:23 .
# ls -l dir1 /* dir1디렉토리의 내용을 출력 */
total 0
-rw-r--r--. 1 root root 0 Mar 25 13:23 file2
# ls -ld dir1 /* dir1디렉토리의 정보를 출력 */
drwxr-xr-x. 2 root root 18 Mar 25 13:23 dir1
# ls -lR /test /* -R: Recursive, 하위 디렉토리까지 */
/test: <해당하는 디렉토리명을 출력한뒤 디렉토리 내부의 파일과 디렉토리를 출력한다.>
total 0
drwxr-xr-x. 2 root root 18 Mar 25 13:23 dir1
-rw-r--r--. 1 root root  0 Mar 25 13:23 file1

/test/dir1:
total 0
-rw-r--r--. 1 root root 0 Mar 25 13:23 file2
​
[EX2] "ls -a" 옵션 실습
# cd 
# pwd
/root
​
일반파일 출력
# ls -l
drwxr-xr-x 2 root root  4096  4월  6 12:17 Desktop
-rw------- 1 root root  4210  1월 25 22:54 anaconda-ks.cfg
-rw-r--r-- 1 root root     0  4월  7 12:38 file_0407.log
-rw-r--r-- 1 root root 54631  1월 25 22:54 install.log
-rw-r--r-- 1 root root  9641  1월 25 22:50 install.log.syslog
​
숨김파일과 일반파일 출력
# ls -al
drwxr-x--- 18 root root  4096  8월 15  2010 .
drwxr-xr-x 26 root root  4096  8월 15  2010 ..
-rw-------  1 root root  2395  8월 15  2010 .bash_history
-rw-r--r--  1 root root    24  1월  6  2007 .bash_logout
-rw-r--r--  1 root root   231  4월  7 10:44 .bash_profile
-rw-r--r--  1 root root   223  4월  7 10:33 .bashrc
..... (중략) .....
drwxr-xr-x  2 root root  4096  4월  6 12:17 Desktop
-rw-------  1 root root  4210  1월 25 22:54 anaconda-ks.cfg
-rw-r--r--  1 root root     0  4월  7 12:38 file_0407.log
-rw-r--r--  1 root root 54631  1월 25 22:54 install.log
-rw-r--r--  1 root root  9641  1월 25 22:50 install.log.syslog

# cd /test
# ls -l
합계 0
drwxr-xr-x. 2 root root 19  3월 12 11:49 dir1
-rw-r--r--. 1 root root  0  3월 12 11:49 file1
# touch .file2
# ls -l
합계 0
drwxr-xr-x. 2 root root 19  3월 12 11:49 dir1
-rw-r--r--. 1 root root  0  3월 12 11:49 file1
# ls -la   /* 숨김파일은 a 옵션을 사용해야만 확인가능하다. */
합계 0
drwxr-xr-x.  3 root root  45  3월 12 12:01 .
dr-xr-xr-x. 19 root root 249  3월 11 18:08 ..
-rw-r--r--.  1 root root   0  3월 12 12:01 .file2
drwxr-xr-x.  2 root root  19  3월 12 11:49 dir1
-rw-r--r--.  1 root root   0  3월 12 11:49 file1
​
[EX3] "ls -F" 옵션 실습
# cd /test 
# rm -rf /test/* 

# cp /etc/passwd file1    /* 일반 파일 */
# ln -s file1 file2       /* 링크 파일 */
# cp /bin/ls file3        /* 실행 파일 */
# mkdir dir1              /* 디렉토리 파일 */

# ls -F   (dir1/  file1  file2@  file3*)
# ls (dir1   file1  file2   file3 )
​
[참고]
리눅스의 경우는 파일, 디렉터리등 종류가 다르다면 다른 색깔로 표시를 해주기 때문에 –F의 경우 그렇게 사용량이 많지는 않다. 하지만 다른 UNIX계열의 OS는 동일하게 표시되기 때문에 알아두자.
[EX4]  ls -i' 옵션 실습
-i는 Index NODE인 inode를 표시해주기 위한 옵션이다. 파일의 속성정보를 담고있는 inode의 구분번호를 표시해 주고 있다. ls –l로 명령어를 입력한 경우의 출력되는 결과들이 저장되어 있다. 
데이터는 Data Block이라는 공간에 별도로 저장되어있다
# ls -li /test/file1 /* inode 번호까지 확인 */
70133672 drwxr-xr-x 2 root root 18  3월  5 12:42 /test/dir1

# ls -ldi /test/dir1 /* inode는 각각 고유한 값을 지님 */
701325642 drwxr-xr-x 2 root root 18  3월  5 12:42 /test/dir1
inode - 파일과 디렉토리에 지정되어 있는 번호
​
[EX5] 파일 또는 디렉토리만 출력
alias(별칭) 명령어를 간편하게 사용하기 위해 사용한다
(선언) # alias ls='ls -h --color=tty'
(확인) # alias
(해제) # unalias ls
# alias lsf='ls -l | grep "^-"' /* 파일인 경우 속성 정보에 -로 표시 */
# alias lsd='ls -l | grep "^d"'/* 디렉토리인 경우 속성 정보에 d로 표시 */
​
# cd 
# lsf
-rw------- 1 root root  4210 Jan 25 22:54 anaconda-ks.cfg
-rw-r--r-- 1 root root 54631 Jan 25 22:54 install.log
-rw-r--r-- 1 root root  9641 Jan 25 22:50 install.log.syslog
-rw-r--r-- 1 root root     0 Jan 26 07:34 local-host-names
-rw------- 1 root root 11665 Jan 26 07:32 mbox
# lsd
drwxr-xr-x 2 root root  4096 Jan 26 02:13 Desktop
​
(참고) 선언된 alias 확인
# alias        alias의 전체목록을 확인
# alias lsf    인자값으로 생성되어 있는 alias가 있다면 출력

​
# alias lsf /* lsf의 alias의 정보 확인 */
alias lsf='ls -l | grep "^-"'

# alias lsd /* lsd의 alias의 정보 확인 */
alias lsd='ls -l | grep "^d"'
​
[EX6] ls -h 옵션 설정(-h : human)
alias를 지정하지 않은 경우
# cd /test
# cat /etc/services >> file1
# cat /etc/services >> file1
# cat /etc/services >> file1
# cat /etc/services >> file1
# cat /etc/services >> file1
# ls –l /etc/services
-rw-r--r--. 1 root root 670293  6월  7  2013 /etc/services
# ls -l file1 
-rw-r--r--. 1 root root 5364652  3월 12 12:13 file1
# ls -lh file1
-rw-r--r--. 1 root root 5.2M  3월 12 12:13 file1
​
이전과 달리 현재는 byte 단위로 용량을 보게 된다면 단위가 너무 많기 때문에 힘들다. 용량이 정확해야 하지 않는다면 –h 옵션을 사용하여 사람이 보기 쉬운형태로 변환하여 사용한다.
# ls -lh /etc/services
-rw-r--r--. 1 root root 670293  6월  7  2013 /etc/services
​
# vi ~/.bashrc     (# gedit ~/.bashrc)

..... (중략) .....
#
# Sfecific Configuration
#
alias ls='ls --color=tty -h'

# . ~/.bashrc     (# source ~/.bashrc)
​
alias를 지정한 경우
# ls –l /etc/services
-rw-r--r--. 1 root root 655K  6월  7  2013 /etc/services
​
보기 편한 형태로 용량이 변경되었다.
[EX7] "ls -altr" 명령어 실습
# ls -altr /tmp    /* -t : time sort, -r : reverse sort */
​
이전파일이 상단에 출력된다.
[참고]
# cd /Log_dir 
# ls –altr
​
ls 명령어에서 이정도는 알아두자.
l 자세하게 출력
a 모든파일 출력(숨김파일 포함)
i inode 번호 출력
h 용량을 사람이 보기 편하게 변경하여 출력
t 시간순 정렬
u 접근시간 으로 변경
r 역방향 정렬때 사용(t옵션과 같이 쓴다.)
F 파일형식 확인
​
mkdir 명령어
새로운 디렉토리를 생성하며, 빈 디렉토리를 생성한다. 옵션을 통하여 여러개의 디렉토리를 한꺼번에 생성 할 수도 있다.
[명령어 형식]
# mkdir dir1              /* 현 디렉토리에 dir1 디렉토리 1개 생성 */
# mkdir dir1 dir2         /* 현 디렉토리에 dir1, dir2 디렉토리 2개 생성 */
# mkdir -p dir3/dir2/dir1 /* dir3 디렉토리 안에 dir2를 생성하고 dir2 안에 dir1을 생성 */
​
[명령어 옵션]
옵션 : 설명
-m : 디렉토리의 퍼미션 권한을 지정 (기본값 : 755)
-p : 디렉토리 경로로 생성 (디렉토리를 만들 때 상위 디렉토리가 없을시 상위 디렉토리까지 생성)
[EX1] mkdir -p 옵션 사용법
# cd /test 
# rm -rf /test/* 
# pwd
/test
# mkdir dir4 
# ls -l
drwxr-xr-x 2 root root 6  3월  5 12:58 dir4
# mkdir dir4/dir2/dir1
mkdir: cannot create directory 'dir4/dir2/dir1': No such file or directory
# mkdir -p dir4/dir2/dir1 
# ls –R   (# find .)
-> 출력 내용 생략
​
rmdir 명령어
[명령어 형식]
# rmdir dir1              /* dir1 디렉토리 1개 삭제 */
# rmdir dir1 dir2         /* dir1, dir2 디렉토리 2개 삭제 */
# rmdir -p dir4/dir2/dir1 /* 경로에 포함되어 있는 디렉토리 삭제 (비워있어야 함) */
​
[명령어 옵션]
옵션 : 설명
-p : 하위항목을 같이 지움 (조건 : 하위항목도 비워 있어야 함)
[참고] 비어 있지 않는 디렉토리 삭제
# rm -rf dir1       /* -r : recursive, -f : force */
​
파일 관리 명령어
touch 명령어
 # touch -t 08301300 file1
cp 명령어
 # cp file1 file2
 # cp file1 dir1
 # cp -r dir1 dir2
mv 명령어
 # mv file1 file2
 # mv file1 dir2
  # mv dir1 dir2
rm 명령어
 # rm -rf dir1
touch 명령어
파일의 이름을 지정하였다면 기존에 존재하지 않는 빈 파일을 만들어주고 기존에 존재하는 파일이라면  지정된 파일이나 디렉토리의 수정시간(mtime, Modify Time)이나 접근시간(atime, Access Time)등을 현재 시간으로 업데이트 시켜준다.
만약 touch 명령어에 -t 옵션을 사용 하여 파일이나 디렉토리의 수정시간을 특정한 시간으로 변경 가능하다.
(해커가 침입하여 파일을 수정하고 아래의 옵션을 통해 수정과 접근 시간을 바꿔놓을 수도 있다.)
[명령어 형식]
# touch file2             /* file2 파일 1개 생성 */
# touch file1 file2       /* file1, file2 파일 2개 생성 */
# touch -t 08081230 file1 /* file1 수정 시간 변경(월,일,시,분) */
​
[명령어 옵션]
옵션 : 설명
-a :                                                  최근 파일 사용기간만 변경
-c :                                                  파일을 생성하지 않는 명령어
-d [시간] :                                       현재 시간 대신 지정한 시간(시분)으로 변경
-m :                                                  최근 파일 변경 시간만 변경 (파일 수정시간)
-r [파일] :                                         현재 시간 대신 지정한 파일의 시간으로 변경
-t MMDDhhmm [[CC]YY][.SS] : 현재 시간 대신 지정한 시간(월일시분)으로 변경
[EX1] 빈 파일 생성
# cd /test 
# rm -rf /test/* 

# touch file1 
# ls -l file1
-rw-r--r-- 1 root root 0  8월 11 12:30 file1
-> 파일의 크기 0
​
[EX2] 파일의 생성 시간 현재시간으로 변경
# date
# cp -p /etc/passwd file2
# ls –l file2
-rw-r--r-- 1 root root 2.0K Jan  7 15:52 file2
-> 시간 정보를 확인한다.

# touch file2 
# ls –l file2
-rw-r--r-- 1 root root 2.0K Jan  8 11:08 file2
-> 시간 정보를 확인한다.

# date
Wed Jan  8 11:08:40 KST 2014
-> 현재 시간을 확인한다.
​
[EX3] touch -t 옵션 사용
# touch -t 08301300 file2 
# ls –l file2
-rw-r--r-- 1 root root 2.0K Aug 30  13:00 file2
​
cp 명령어
파일이나 디렉토리의 내용을 다른 파일 또는 다른 디렉토리에 복사 할 때 사용. 파일을 복사하는 것은 물리적으로 새로운 파일을 하나 생성하며 새로운 파일의 이름과 새로운 inode, 복사된 데이터 블록을 가지게 된다.
[명령어 형식]
# cp file1 file2   /* file1 파일내용을 file2로 생성 */
# cp file1 dir1   /* file1 파일내용을 dir1디렉토리에 file1 생성 */
# cp -r dir1 dir2 /* dir1 디렉토리를 dir2디렉토리로 생성 */
# cp 원본 타겟
​
[명령어 옵션]
옵션 : 내용
-a : 원본 파일의 속성, 링크 정보를 유지 하면서 복사
-b : 복사할 대상을 덮어쓰거나 지울 때를 대비해서 백업 파일 만듦 백업파일의 파일명 뒤에는 ~가 표시된다.
-d : 심볼릭 파일 자체를 심볼릭 정보와 함께 복사할 때 사용
-f : 복사할 파일이 존재할 때 삭제하고 복사
-i : 복사할 파일이 존재하는 경우 복사할 것인지 물어봄
-l :디렉토리가 아닌 경우 복사 대신 하드 링크로 만듦
-p : 원본 파일의 소유, 그룹, 권한, 허용 시간을 보존한 채로 복사
-r : 서브 디렉토리 내에 있는 모든 파일까지 통째로 복사
-s : 디렉토리가 아닌 경우 복사 대신 심볼릭 링크로 만듦
-u : 대상 파일보다 원본 파일이 새로운 것일 때 복사
-v : 복사 상태를 보여줌
[EX1] 파일에 대한 inode를 확인
			■ 파일의 일반적인 구조(EX: 일반 파일)

								 +-------------+
      file1 ---->| Inode       |   정보 블럭
								 +-------------+
								 |             |
								 | Data Block  |   데이터 블럭
								 |             |
								 +-------------+

			■ Inode Number ?
​
# cd /test 
# rm -rf /test/* 

# touch file1 
# ls -li file1
4039445 -rw-r--r-- 1 root root 0 Jan 26 11:34 file1

# cp file1 file2 
# ls -li file2      /* 복사하면서 inode가 바뀐 걸 볼 수 있음. */
4039452 -rw-r--r-- 1 root root 0 Jan 26 11:35 file2
​
[EX2] cp 명령어의 -r 옵션
# cd /test 
# rm -r /test/* 

# mkdir dir1 
# touch dir1/file1 dir1/file2 

# cp -r dir1 dir2 
# ls -lR
drwxr-xr-x 2 root root 4096 Jan 26 11:36 dir1
drwxr-xr-x 2 root root 4096 Jan 26 11:37 dir2

./dir1:
total 0
-rw-r--r-- 1 root root 0 Jan 26 11:36 file1
-rw-r--r-- 1 root root 0 Jan 26 11:36 file2

./dir2:
total 0
-rw-r--r-- 1 root root 0 Jan 26 11:37 file1
-rw-r--r-- 1 root root 0 Jan 26 11:37 file2

# cp -r dir1 dir2 
# ls -lR 
	# cp -r /home/fedora/test1 /tmp/fedorahomefile
	# cp -r /test /tmp
​
[EX3] cp를 이용하여 같은 파일에 덮어 쓰기(Overwrite)하는 경우
# cd /test 
# rm -rf /test/*

# mkdir dir1 
# echo "linux200" > file1 
# cat file1
linux200

# touch dir1/file1 /* 동일한 파일명으로 파일 생성 */
# cat dir1/file1   /* 이름만 동일 할 뿐 내용 다름 */
#

# cp file1 dir1    /* 동일한 파일명에 덮어쓰기 */
cp: overwrite `dir1/file1'? y

# ls -lR
.:
total 8
drwxr-xr-x 2 root root 4096 Jan 26 23:39 dir1
-rw-r--r-- 1 root root    9 Jan 26 23:39 file1

./dir1:
total 4
-rw-r--r-- 1 root root 9 Jan 26 23:40 file1

# cat dir1/file1    /* copy 내용 확인 가능 */
linux200

-f 옵션 실습하기
# cp file1 file2
# echo "Linux252" >> file1
# unalias cp 
